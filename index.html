<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Modelo 3D Interactivo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #uploadButton {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <button id="uploadButton">
        <img
            src="https://static.wixstatic.com/shapes/8f321f_8297b2c2d19b4e36a6b117617b565d19.svg"
            alt="Subir textura"
            width="50"
        />
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let scene, camera, renderer, model, chango, C1, C2;
        let rotationSpeed = 0;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const raycaster = new THREE.Raycaster(); // Crear un rayo para raycasting
        const mouse = new THREE.Vector2(); // Crear un vector para la posición del mouse
        let isC2Animating = false; // Variable para controlar la animación de C2

        init();
        animate();

        function init() {
            // Crear la escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Crear la cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 5); // Aumenta la distancia en el eje Z para alejar el modelo

            // Crear el renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Añadir luz
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Cargar el modelo 3D
            const loader = new THREE.GLTFLoader();
            loader.load(
                'https://static.wixstatic.com/3d/8f321f_9f4a699028e246cfa74ffa9eeb679317.glb', // URL de tu modelo
                function (gltf) {
                    model = gltf.scene;
                    chango = model.getObjectByName('chango'); // Obtiene el elemento chango
                    C1 = model.getObjectByName('C1'); // Obtiene el elemento C1
                    C2 = model.getObjectByName('C2'); // Obtiene el elemento C2
                    scene.add(model);
                },
                undefined,
                function (error) {
                    console.error('Error al cargar el modelo:', error);
                }
            );

            // Eventos de interacción
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('click', onDocumentClick, false); // Agregar evento de clic

            // Redimensionar la ventana
            window.addEventListener('resize', onWindowResize, false);

            // Botón para cargar texturas
            document
                .getElementById('uploadButton')
                .addEventListener('click', function () {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = function (event) {
                        const file = event.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const textureLoader = new THREE.TextureLoader();
                            const texture = textureLoader.load(e.target.result, function () {
                                model.traverse(function (child) {
                                    if (child.isMesh && child.name === "Cylinder") {
                                        child.material.map = texture;
                                        child.material.needsUpdate = true;
                                    }
                                });
                            });
                        };
                        reader.readAsDataURL(file);
                    };
                    input.click();
                });
        }

        // Función para redimensionar la ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Eventos para arrastrar y rotar el modelo
        function onDocumentMouseDown(event) {
            isDragging = true;
        }

        function onDocumentMouseUp(event) {
            isDragging = false;
        }

        function onDocumentMouseMove(event) {
            if (isDragging) {
                const deltaMove = {
                    x: event.offsetX - previousMousePosition.x,
                };

                rotationSpeed = deltaMove.x * 0.005;
            }

            previousMousePosition = {
                x: event.offsetX,
                y: event.offsetY,
            };
        }

        // Evento de clic para detectar clics en C1 y C2
        function onDocumentClick(event) {
            // Calcular la posición del mouse en el espacio de la ventana
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Actualizar el raycaster
            raycaster.setFromCamera(mouse, camera);

            // Calcular objetos intersecados
            const intersects = raycaster.intersectObjects(model.children, true);

            // Revisar si se intersectó C1 o C2
            intersects.forEach((intersect) => {
                if (intersect.object.name === 'C1') {
                    // Aumentar el tamaño de C1
                    intersect.object.scale.set(1.2, 1.2, 1.2); // Aumenta el tamaño en un 20%
                }
                if (intersect.object.name === 'C2') {
                    isC2Animating = true; // Activar la animación de C2
                }
            });

            // Cambiar color de chango
            intersects.forEach((intersect) => {
                if (intersect.object.name === 'C1') {
                    chango.material.color.set(0x000DFF); // Cambiar color a azul
                }
                if (intersect.object.name === 'C2') {
                    chango.material.color.set(0xFF7300); // Cambiar color a naranja
                }
            });
        }

        // Animar la escena
        function animate() {
            requestAnimationFrame(animate);

            if (model) {
                // Rotación automática de chango
                if (chango) {
                    chango.rotation.y += 0.01; // Ajusta la velocidad de rotación
                }

                // Animar C2 si isC2Animating es verdadero
                if (isC2Animating) {
                    C2.rotation.y += 0.05; // Rotación o animación para C2
                }

                rotationSpeed *= 0.95; // Agregar fricción a la rotación
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
